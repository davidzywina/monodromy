/*
The following is an implementation of some of the results from the paper "Computing monodromy of abelian varieties" 
See http://pi.math.cornell.edu/~zywina/papers/Monodromy/Monodromy.pdf
*/


/*
We define a record type "FrobTorusRec" that encodes the Frobenius torus T of a non-zero abelian variety A over a finite field F_q.
Let Phi be the (multiplicative) group generated by the roots of the Frobenius polynomial P of A.
    q:          the cardinality of the finite field
    P:          the Frobenius polynomial of A
    g:          the dimension of A
    ordinary:   true if A is ordinary and false otherwise
    roots:      sequence consisting of the distinct roots of P (computed in some nonarchimedean local field)
    mult:       sequence of multiplicities of the "roots" of P
    Gamma:      the Galois group of P; given as a permutation group on "roots"
    iota:       the (surjective) group homomorphism Z^(#roots)-> Phi that maps e_i to the i-th root in "roots"
    X:          the cokernel of iota; it is isomorphic to Phi
    free:       true if X (equivalently, Phi) is a free abelian group and false otherwise
    rank:       the rank of X (equivalently, the dimension of T)
    phi:        when X is free, a homomorphism Gamma -> GL_r(Z), with r=rank(X), giving the natural action of Gamma on X 
                (this uses the isomorphism iota and the action of Gamma on Phi)   

When we can identify T with a maximal torus of a Mumford-Tate group MT, the record also encodes info about this reductive group.
     dimMT:     dimension of MT
     R:         the roots of MT with respect to T; given as a sequence of irreducible root systems in X
     Delta:     a choice of simple roots; given as a sequence with respect to the ordering of irreducible root systems of R
     lie:       sequence of Lie types for the irreducible root systems in R; they will be An, Bn, Cn or Dn (exceptional types will not occur)
     W:         the Weyl group W(MT,T).  When this is used, W will be a subgroup of the Galois group Gamma and we will have Gamma=Gamma(MT,T).
*/

FrobTorusRec := recformat< P:RngUPolElt, q:RngIntElt,  roots,mult,R,lie,Delta,EndC:SeqEnum, Gamma, W:GrpPerm, X:ModED, 
                           iota:Map, phi:HomGrp, free,ordinary:BoolElt, g,rank, dimMT, dimEnd:RngIntElt>;


// Note:        In Magma, groups usually act on the right (while they act on the left in the paper).  
//              This is not a serious issue since almost all the computations involve only orbits.


function ComputeFrobeniusTorus(P: Q:=1, Proof:=false, ReturnOnlyW:=false)
/* Input:   P is the Frobenius polynomial of a nonzero abelian variety A over a finite field F_q.
            Q is a polynomial with rational coefficients that is relatively prime to P.

   Output:  returns a record T of type "FrobTorusRec".   
            The following quantities in the description of "FrobTorusRec" for P are computed: 
                g, P, ordinary, roots, mult, Gamma, iota, X, free, rank, phi.

            NOTE: Currently these quantities are only all computed when A is ordinary and the multiplicative group generated by the roots of P is free.
                 "ordinary" is always computed, and "free" is computed if "ordinary" is true.

            A group W is also computed for T.  It is the subgroup of Gamma that we can identify with the Galois group of P over the splitting field 
            of the polynomial Q.  Only the group W is returned if "ReturnOnlyW" is true.   

   In Magma, Galois groups are computed conditionally.  Set "Proof" to be true if you want all Galois group computations to be verified.        
*/
    Pol<x>:=PolynomialRing(Rationals());
    P:=Pol!P;  Q:=Pol!Q;
    assert GCD(P,Q) eq 1;

    //  We want the Frobenius polynomial P to be monic; we reverse it if necessary.
    if not IsMonic(P) then 
        P:= Pol!( x^Degree(P)*Evaluate(P,1/x) );
        assert IsMonic(P);
    end if;

    // We first compute q and the characteristic p of F_q.
    _,q:=IsPower(Integers()!Coefficient(P,0), Degree(P) div 2);
    p:=PrimeDivisors(q)[1];

    // We ensure that the abelian variety has ordinary reduction.  
    if Integers()!Coefficient(P,Degree(P) div 2) mod p eq 0 then
        return rec<FrobTorusRec | q:=q, P:=P, ordinary:=false>;
    end if;

    // Let P0 be the radical of P; the square-free monic polynomial with the same roots of P.
    // We also replace Q by its radical.
    P0:=&*[f[1]:f in Factorization(P)];  
    if Degree(Q) ge 1 then Q:=&*[f[1]:f in Factorization(Q)]; end if;
    
    d:=Degree(P0); e:=Degree(P0*Q);

    // We compute the Galois group of P*Q. 
    G0,roots,S0:=GaloisGroup(P0*Q);
    if Proof then assert GaloisProof(P0*Q,S0); end if;

    K:=Parent(roots[1]); // K is a nonarchimedean local field
    // We now check some conditions that should be immediate from the GaloisGroup implementation.
    assert RamificationDegree(K) eq 1 and Prime(K) ne 2;   
    assert true notin {IsWeaklyEqual(roots[i],roots[j]): i,j in [1..#roots] | i ne j};
    prec:=Minimum([GetPrecision(a): a in roots]);

    //  We order the distinct roots of P*Q so that the roots of P show up first.  
    //  The roots of P are ordered so that there are d/2 roots followed by their complex conjugates in the same order,
    //  where d=deg(P0).  Note that P has no real roots, and d is even, by our ordinary assumption.
    rootsP:=[r: r in roots | IsWeaklyZero(Evaluate(P0,r))]; 
    roots1:=[]; roots2:=[];
    for i in [1..d] do
        if &or[IsWeaklyEqual(r,rootsP[i]): r in roots1 cat roots2] eq false then
            roots1:=roots1 cat [rootsP[i]]; 
            roots2:=roots2 cat [q/rootsP[i]];    
        end if;
    end for;
    rootsP:=roots1 cat roots2;
    if Q eq 1 then rootsQ:=[]; else rootsQ:=[r: r in roots | IsWeaklyZero(Evaluate(Q,r))]; end if;

    roots1:=rootsP cat rootsQ;
    // We now alter the Galois group G0 of P*Q so that it acts with respect to our reordered sequence of roots "roots1".
    ind:=[ [j:j in [1..e] | IsWeaklyEqual(roots1[j],roots[i])][1] : i in [1..e]];
    sigma:=SymmetricGroup(e)!ind; 
    G0:=sub<SymmetricGroup(e)|[sigma^(-1)*g*sigma: g in Generators(G0)]>;

    //  We now compute the Galois group Gamma of P over the rationals and the Galois group W of P over the splitting field of Q.
    //  We view Gamma and W as subgroups of the symmetric group on the distinct roots of P ordered as in "rootsP".
    Sd:=SymmetricGroup(d);
    Gamma:=sub<Sd|[Sd![ElementToSequence(g)[i]: i in [1..d]] : g in Generators(G0)]>;
    
    H1:=&meet[Stabilizer(G0,i): i in [1..d]];
    if Q eq 1 then 
        H2:=G0; 
    else 
        H2:=&meet[Stabilizer(G0,i): i in [d+1..e]]; 
    end if;
    H:=sub<G0| Generators(H1) join Generators(H2) >;        
    W:=sub<Sd|[Sd![ElementToSequence(g)[i]: i in [1..d]] : g in Generators(H1) join Generators(H2)]>;
    if ReturnOnlyW then return W; end if;
    
    //Compute the multiplicities of roots of P ordered as in "rootsP"
    FF:=Factorization(P);
    mult:=[ [f[2]: f in FF | IsWeaklyZero(Evaluate(f[1],r))][1] : r in rootsP];



    // We now try to compute the multiplicative group X generated by "rootsP"; 
    // X will be given as a quotient of the group M:=Z^d modulo a subgroup of relations.
    // Currently, the function will return early if X is not free abelian.

    M:=RModule(Integers(),d);

    QQ:=Prime(K)^InertiaDegree(K);  
    // QQ is the cardinality of the residue field of the local field K  
    // We will use below that any roots of unity in K have distinct images in the residue field which has order QQ

    free:=true;
    good:={}; bad:={};
    for I in Subsets({1..d div 2}) do

        S:=I join {i+d div 2: i in {1..d div 2} | i notin I};
        if S in good or S in bad then continue I; end if;

        H:=Stabilizer(Gamma,S); C:=Transversal(Gamma,H); 
        SS:={S^g: g in C};  // Gamma-orbits of S in {1,...,d}

        A:=Matrix([ Coordinates(M,&+{M.i:i in S}) : S in SS ]); 
        R:=Kernel(Transpose(A));

        // We now check if R gives multiplicative relations between the number "rootsP"
        valid:=true;
        for w in Basis(R) do
            m:=Coordinates(M,M!w); 
            u:=&*[rootsP[i]^m[i]:i in [1..d]];

            if IsWeaklyEqual(u^(QQ-1),1) eq false then
                valid:=false; break w;
            end if;

            for e0 in Divisors(QQ-1) do
                if IsWeaklyEqual(u^e0,1) then e1:=e0; break; end if;
            end for;
            a:=[e1*Maximum( m[i],0): i in [1..d]];
            b:=[e1*Maximum(-m[i],0): i in [1..d]];

            // We now check that our numerically tested multiplicative relations in K are actual true.
            // We may need to compute the roots of P to a higher precision first.
            prec0:=1+ Ceiling( #Gamma/(2*InertiaDegree(K)) * Log(4*q^Maximum([&+a,&+b]))/Log(Prime(K)) );
            if prec0 gt prec then    
                prec:=prec0;
                roots:=[ GaloisRoot(P0*Q,i,S0:Scaled:=false, Prec:=prec0) : i in [1..e]];           
                rootsP:=[ [r: r in roots | IsWeaklyEqual(r,b)][1] : b in rootsP ];
            end if;
            alpha:= &*[rootsP[i]^a[i]:i in [1..d]] - &*[rootsP[i]^b[i]:i in [1..d]];
            if IsWeaklyZero(alpha) eq false then
                valid:=false; break w; 
            end if;

            if e1 ne 1 then
               // Return early if we have verified the existence of non-trivial torsion. 
               return rec<FrobTorusRec | q:=q, P:=P, ordinary:=true, free:=false>;    
            end if;
        end for;

        if valid then good:=good join SS; else bad:=bad join SS; end if;
    end for;


    A:=Matrix([ Coordinates(M,&+{M.i:i in S}) : S in good ]);
    R:=Kernel(Transpose(A));

    // multiplicative subgroup X generated by roots of P, where "rootsP" are identifyied with the standard basis of M
    X,iota:=quo<M|R>;  


    // We now define the natural (right) action of the Galois group Gamma on X   
    GLr:=GL(Rank(X),Integers());    
    BB:=[];
    for i in [1..Ngens(Gamma)] do
        g:=Gamma.i;
        B:=[];
        for w in Basis(X) do
            m:=w @@ iota; 
            c:=Coordinates(M,m);
            B:=B cat [Coordinates(X, iota(&+[c[i]*M.(i^g): i in [1..Rank(M)]]) )];
        end for;
        B:=Matrix(B);
        BB:=BB cat [(GLr!B)]; 
    end for;       
    phi:=hom<Gamma->GLr | BB>;

    T:=rec<FrobTorusRec |   q:=q, P:=P, g:=Degree(P) div 2, roots:=rootsP, mult:=mult, Gamma:=Gamma, 
                            W:=W, X:=X, iota:=iota, rank:=Rank(X), phi:=phi, ordinary:=true, free:=true>;    
    return T;
end function;


function ComputeRoots(T)
/* Input:   T a record of type "FrobTorusRec" as produced by the function "ComputeFrobeniusTorus".
   We further assume that the Weyl group W=T`W is known.

   Assuming T is the maximal torus of a Mumford-Tate group MT with Weyl group W, the following additional values of the record T are found:
   dimMT, R, Delta, lie.

   Output:  a flag and the updated T.
            The flag is false if the root datum could not be computed (this could happen when there is incorrect input).                     
*/ 

    Gamma:=T`Gamma;  W:=T`W;  iota:=T`iota;  X:=T`X;  phi:=T`phi;  rank:=T`rank;
    M:=Domain(iota); 

    OrbitsW:=Orbits(W);
    OrbitsW:=Sort(OrbitsW,func<x,y|#x-#y>); // Sort by increasing cardinality

    CC :=[ {iota(M.a-M.b): a,b in OrbitsW[i]} diff {X!0} : i in [1..#OrbitsW] ];
    U1:=&join CC;
 
    if U1 eq {} then  // In this case, the Mumford-Tate group equals the torus T.
        T`lie:=[];  T`R:=[];  T`Delta:=[]; T`dimMT:=T`rank;
        return true, T;
    end if;

    // Define the natural (right) action U1 x W -> U1
    U1xW := CartesianProduct(U1,W);
    f := map< U1xW -> U1 | x :-> Vector(ElementToSequence(x[1]))*phi(x[2]) >;  
    U1_:=GSet(W,U1,f);

    Orb:=Orbits(W,U1_);
    Orb:=Sort(Orb,func<x,y|#x-#y>); // Sort by increasing cardinality
   
    // We now compute a sequence SS of finite sets of characters; each will contain a unique irreducible root system.
    i:=1; U:=U1;
    done:=false;
    SS:=[];
    V:=KModule(Rationals(),rank);
    while not done do
        j:=[i: i in [1..#Orb] | Orb[i] subset U][1];
        O:=Orb[j];  
        C:=[C: C in CC | O subset C][1];

        V0:=sub<V|[Coordinates(X,a): a in O]>;
        S:={a: a in C |  V!Coordinates(X,a) in V0};
        SS:=SS cat [S];

        V0:=sub<V|[Coordinates(X,a): a in (&join SS)]>;
        U:={a: a in U |  V!Coordinates(X,a) notin V0};
        if #U ne 0 then i:=i+1; end if;
        if #U eq 0 then done:=true; end if;
    end while;
            
    // The following is an inner product on X.
    function B(a,b)
        v:=ChangeRing(Matrix([Coordinates(X,a)]),Rationals()); 
        w:=ChangeRing(Matrix([Coordinates(X,b)]),Rationals()); 
        return (v*Transpose(w))[1,1];
    end function;

    // We now find the roots and their decomposition into irreducible root systems.
    lie:=[]; R:=[];  Delta:=[];
    for i in [1..#SS] do
        S:=SS[i];
        V0:=sub<V|[Coordinates(X,a): a in S]>;
        r:=Dimension(V0);
        weyl:=#W div #&meet[Stabilizer(W,U1_,a): a in S]; 
        Orb0:=[Set(O): O in Orb | O subset S];

        if r ge 1 and weyl eq Factorial(r+1) then
            lie0:="A" cat IntegerToString(r);
            R0:=&join[O: O in Orb0 | #O eq r*(r+1)];
        elif r ge 3 and weyl eq 2^r*Factorial(r) and #Orb0 ge 3 then
            lie0:="B" cat IntegerToString(r);
            R0:=&join[O: O in Orb0 | #O in {2*r,2*r*(r-1)}];
        elif r ge 2 and weyl eq 2^r*Factorial(r) and #Orb0 eq 2 then
            lie0:="C" cat IntegerToString(r);
            R0:=&join[O: O in Orb0];
        elif r ge 4 and weyl eq 2^(r-1)*Factorial(r) then
            lie0:="D" cat IntegerToString(r);
            R0:=&join[O: O in Orb0 | #O eq 2*r*(r-1)];      
        else
            // Lie type not determined (incorrect input).  Note that exceptional Lie types should not occur.
            return false, T;
        end if;

        // We now compute a set Delta0 of simple roots of R0.  
        Y:=sub<X|R0>;
        // We first find an element y in Y that is not orthogonal to any element of R0.
        v:=X!0;
        R0_:=[a: a in R0];
        for i in [1..#R0_] do
            if B(R0_[i],v) eq 0 then
                w:=[X!y: y in Basis(Y) | B(X!y,R0_[i]) ne 0][1];
                repeat
                    v:=v+w;
                until 0 notin {B(R0_[j],v): j in [1..i]};
            end if;
        end for;
       
        Positive:={a: a in R0 | B(v,a) gt 0};
        Delta0:= Positive diff {a+b: a,b in Positive};
        assert #Delta0 eq Rank(Y);
        Delta0:=[a: a in Delta0];


        Delta:= Delta cat [Delta0];
        lie:=lie cat [lie0];
        R:=R cat [R0]; 
    end for;

    T`lie:=lie;  T`R:=R;  T`Delta:=Delta;    
    T`dimMT:=&+([#R0: R0 in R] cat [T`rank]);

    return true, T;
end function;



function ComputeRootDatumOfMT(S :Proof:=false)
/*  Input:   S is a set of Frobenius polynomials of a nonzero abelian variety A over a number field.

    From the set S, the function attempts(!) to compute the root datum of the Mumford-Tate group of A with respect to a Frobenius torus.
    Output:  Returns false if the root datum could not be determined (in practice, more polynomials are required).
             Otherwise returns true and a record of "FrobTorusRec" that encodes the root datum.   
             
            Warning:  The root datum is not guaranteed to be correct, but will be correct given enough suitable Frobenius polynomials.   
            This algorithm assumes the Mumford-Tate conjecture for A (we are only using primes of ordinary reduction which means the other 
            conjecture of the paper is not used).

    In Magma, Galois groups are computed conditionally.  Set "Proof" to be true if you want all Galois group computations to be verified.        
*/
    if #S lt 2 then return false, []; end if;  // Need at least two polynomials
    g:=Degree(Rep(S)) div 2;  // dimension of A

    TT:=[];
    for P in S do
        T:=ComputeFrobeniusTorus(P :Q:=1, Proof:=Proof);
        if T`ordinary and T`free then
            TT:=TT cat [T]; 

            // We can recognize when we have full GSp_2g monodromy from a single torus. 
            if T`rank eq g+1 and #T`Gamma eq 2^g*Factorial(g) then
                    flag,T:= ComputeRoots(T);
                    return flag, T;
            end if;
        end if;
    end for;
    if #TT lt 2 then return false, []; end if;  // Not enough suitable polynomials in S

    // From the Frobenius polynomials, the expected rank of the Mumford-Tate group:
    r:=Maximum([T`rank: T in TT]);

    TT:=[T: T in TT | T`rank eq r];
    if #TT lt 2 then return false, []; end if;  // Not enough suitable polynomials in S

    Q:=TT[1]`P; 
    TT:=[TT[i]: i in [2..#TT]];
    w,i:=Maximum( [ #ComputeFrobeniusTorus(T`P: Q:=Q, ReturnOnlyW:=true, Proof:=Proof) : T in TT] );

    T:=ComputeFrobeniusTorus(TT[i]`P: Q:=Q, Proof:=Proof);
    flag,T:= ComputeRoots(T);
    return flag, T;
end function;


function ComputeMoments(T,k,N)
/* Input:   a record T of type "FrobTorusRec"; it corresponds to a maximal torus of a Mumford-Tate group and we assume its root datum has been computed.
            k is a positive integer
            N is a finite sequence of nonnegative integers.
   Output:  Returns the sequence of moments M_{k,N}=E[a_k^n] with n in N.
*/
    iota:=T`iota; X:=T`X;
    mult:=T`mult; d:=#T`roots;  
    M:=Domain(iota); 
 
    X2,iota2:=quo<X|sub<X|iota(M.1+M.(1+d div 2))>>;

    P<[t]> := PolynomialRing(Rationals(), Rank(X2));

    // Find factor for Weyl integration formula
    Jac:=1;
    for a in &join T`R do
        e:=Coordinates(X2,iota2(a));
        u:=&*([t[i]^e[i]: i in [1..Rank(X2)] | e[i] gt 0] cat [1]);
        v:=&*([t[i]^(-e[i]): i in [1..Rank(X2)] | e[i] lt 0] cat [1]);
        Jac:=Jac*(1 - u/v);
    end for;
    Jac:=Jac/#T`W;  

    ak:=0;
    ee:=[];
    for i in [1..Rank(M)] do
        e:=Coordinates(X2,iota2(iota(M.i)));
        for j in [1..mult[i]] do  ee:=ee cat [e]; end for;
    end for;
    for J in Subsets({1..2*T`g},k) do
        c:=1;
        for j in J do
            u:=&*([t[i]^ee[j][i]: i in [1..Rank(X2)] | ee[j][i] gt 0] cat [1]);
            v:=&*([t[i]^(-ee[j][i]): i in [1..Rank(X2)] | ee[j][i] lt 0] cat [1]);
            c:=c*u/v;
        end for;
        ak:=ak+c;
    end for;

    moments:=[];
    for n in N do
        u:=ak^n*Jac;
        den:=Denominator(u); assert IsMonomial(den);
        num:=Numerator(u);
        moments:= moments cat [MonomialCoefficient(num,den)];
    end for;

    return moments;   
end function;


function ComputeEnd(T)
/* Input:   a record T of type "FrobTorusRec"; it corresponds to a maximal torus of a Mumford-Tate of an abelian variety A.
   Output:  Up to isogeny over an algebraic closure, A is isogenous to a product of abelian varieties B_i^ni, 
            where the B_i are simple and pairwise non-isogenous.
            The function outputs two sequences.  The first consists of the dimension of the B_i^ni.
            The second sequence consists of pairs (d_i,m_i), where the endomorphism ring of B_i^ni tensored up to Q is
            a central simple algebra of dimension m_i^2 over a number field of degree d_i.
*/
    dim:=[];  End:=[];
    Gamma:=T`Gamma;  
    W:=T`W;

    Orb:=Orbits(W);
    for J0 in Orbits(Gamma) do
        J:=[J : J in Orb | J subset J0][1];
        H:=Stabilizer(Gamma,J);
        End:=End cat [ [Index(Gamma,H), T`mult[Rep(J)] ] ];
        dim:=dim cat [&+[T`mult[i]: i in J0]/2];
    end for;

    return dim, End;
end function;


procedure PrintFrobTorusInfo(T)
    // For a Frobenius torus T, i.e., a record of type "FrobTorusRec", we output some information.
    
    if assigned T`R then
        print "dim(A) =",T`g;
        print "dim(MT) =",T`dimMT;
        print "rank(MT) =",T`rank;
        print "Dyn(MT) =",T`lie;
        print "Index of W in Gamma=", #T`Gamma div #T`W;
        print "Orbits of weights under Gamma =",[Set(A): A in Orbits(T`Gamma)];
        print "Orbits of weights under W =",[Set(A): A in Orbits(T`W)];
        print "multiplicity of weights =",T`mult;

        dim, End:=ComputeEnd(T); " ";
        print "Over Qbar, A is isogenous to a product of A_i that are powers of pairwise nonisogenous simple abelian varieties." ;
        print "Each ring End^0(A_i) is central simple algebra of dimension m_i^2 over its center which is a number field of degree d_i.";
        print "Dimension of the A_i :", dim;
        print "Pairs (d_i,m_i) :"; End;
    end if;
end procedure;

